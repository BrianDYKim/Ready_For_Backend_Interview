### 1. 배열과 연결리스트의 차이점에 대해서 설명해주실래요?

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* 배열은 연속된 memory space를 할당받으며, 연결리스트는 비연속적인 memory space를 활용한다는데서 큰 차이점을 보인다.
* 배열은 사용하는 memory space가 연속적이기 때문에 Cache locality에 의해서 접근 속도가 연결리스트에 비해서 빠르다는 것이 특징이다.
* 배열의 경우 인덱스를 기반으로 데이터에 접근이 가능하기 때문에 연결리스트에 비해서 조회 속도가 빠르다는 것도 특징이다.
* 배열의 경우 데이터 추가, 삭제에 대해서 복잡도가 매우 크지만, 연결리스트의 경우 데이터의 추가, 삭제에 있어서 거의 균일한 시간복잡도를 보여준다는 것이 특징이다.
* 연결리스트는 데이터를 저장함에 있어서 이전 노드가 다음 노드를 기억해야한다는 특징이 있어서 배열에 비해서 공간복잡도가 더 크다는 특징을 가진다.

</div>
</details>

### 2. List와 Set의 차이점에 대해서 설명해주실래요?

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* List와 Set은 둘다 선형 자료구조이지만, 큰 차이점이라면 **데이터를 저장하는데 있어서 순서성이 보장되느냐, 보장되지 않느냐에 큰 차이점이 존재한다.**
* List의 경우 1번 질문에서 설명했듯이 데이터를 조회하기 위해서는 O(N)의 복잡도가 요구되지만, Set의 경우 내부적으로 Hash Table을 기반으로 구현이 되어있기 때문에 
O(1)의 복잡도를 가진다.
* List 자료구조는 데이터의 순서성이 보장되거나, 혹은 중요할 때 사용하면 유리하고, Set의 경우 데이터의 유무, 존재성을 따지는 경우에 유리하다고 판단한다.

</div>
</details>

### 3. Hash Table에 대해서 설명해주세요

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* Hash Table은 내부적으로 **Bucket** 이라고 불리는 배열이 존재하고, 들어오는 데이터에 대해서 hash function을 통해 데이터를 해싱하고, 해시값을 기반으로 Bucket에 데이터를 보관한다.
* Bucket은 배열이고, 데이터를 검색할 때도 hash function을 거쳐서 인덱스를 찾아서 검색을 하면 되기 때문에 일반적으로 O(1)이라는 시간복잡도를 가진다. **(가끔 해쉬값이 겹치는 Collision 현상이 벌어질 수도 있는데, 이런 경우에는 Bucket의 인덱스 내부에 선형적으로 데이터를 저장하여 선형탐색을 하게된다.)**
* Bucket은 결국 배열이기 때문에 연속적인 메모리 space를 가진다. 따라서 Cache locality 효과를 누릴수 있기 때문에 탐색 성능이 향상되는 효과를 가진다.
* 위의 특징들 때문에 NoSQL은 Hash Table을 기반으로 하여 높은 쓰로풋을 발휘할 수 있다.
* 단일 데이터를 탐색하는데 있어서 시간 복잡도가 O(1)이 거의 보장이 되기 때문에 성능이 높으나, 범위 탐색의 경우 성능이 뒤떨어질 수 있다는 특징도 가지고있다.

</div>
</details>

### 4. Stack, Queue에 대해서 설명해주실래요?

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* Stack, Queue 모두 선형 자료구조이다.
* Stack은 후입선출 방식의 자료구조이다.
* Queue는 선입선출 방식의 자료구조이다.
* Stack, Queue는 모두 리스트를 기반으로 구현이 되어있다. 왜냐하면 Stack, Queue는 가변배열을 기반으로 작성하는 것이 매우 유리하기 때문에 가변적으로 길이를 조절할 수 있는 리스트가 Stack, Queue 구현에 사용된다.

</div>
</details>

### 5. Heap, Priority Queue에 대해서 설명해주실래요?

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* Heap 자료구조는 **특정 기준으로 데이터를 삽입, 삭제하는 자료구조이다.**
* Heap 자료구조는 내부적으로 배열을 기반으로 작성한다. **(윤성우의 열혈 자료구조 참고하시면 되겠습니다.)**
* Heap 자료구조는 삽입, 조회, 삭제 모두 O(logN) 의 복잡도를 가진다.
* 삽입의 경우 Heap의 맨 마지막 인덱스에 데이터를 추가한 다음, Heap의 데이터 관리 정책에 따라서 부모, 동료 노드간의 비교를 통해서 제자리를 찾아가는 방식으로 삽입이 발생한다.
* 조회또한 root Node로부터 데이터 관리 정책에 따라 자식, 동료간 비교를 통해 데이터를 조회한다.
* 삭제의 경우 root Node를 pop 시키는 방식으로 동작하며, 삭제가 발생하면 마지막 인덱스의 원소를 삭제. 삽입하여 맨 마지막 인덱스가 삽입된 효과를 발생시켜 Heap을 정렬시킨다.
* Priority Queue의 경우 이러한 Heap을 기반으로 구현이 되며, Heap의 **데이터 관리 정책을 본인의 우선순위 정책으로 치환시켜서 구현한다.**
* Heap 자료구조를 배열로 구현하는 경우 마찬가지로 Cache Locality 효과 덕분에 성능이 향상되는 효과를 보인다. **(사실 웬만하면 배열로 구현하는게 성능상 뛰어나겠지만...불가능한 경우도 많다.)**

</div>
</details>

### 6. Tree, Binary Tree, BST에 대해서 설명해주세요

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* Tree 자료구조의 경우 자신의 Node를 기준으로 child를 두는 방식으로 구현이 되는데, 이러한 child 또한 Tree라는 특징을 가진다. 즉, Tree의 정의는 재귀적이라고 볼수도 있다.
* 극단적으로, 단일 노드또한 하나의 Tree라고 볼수도 있다. 다만 child가 없는 Tree일 뿐이다.
* Binary Tree의 경우 단말 노드를 제외하면 자식을 최대한 2개만 가지도록하는 Tree 자료구조이다.
* BST의 경우 Binary Tree이긴한데, 특정 노드를 기준으로 자신의 left child는 무조건 자신보다 작아야하고, right child는 자신보다 커야한다는 특징을 가진다.

</div>
</details>

### 7. BST의 최악의 경우를 제시하고, 이 때의 시간복잡도는 얼마인가요?

<details>
<summary>접기/숨기기</summary>
<div markdown="1">

* BST는 1~N 까지의 데이터가 순차적으로 들어오는 경우 최악의 성능을 보입니다. 이러한 경우 임의의 자연수 K < N에 대해서 K번째 노드가 있을 때 K + 1번째 노드는 무조건 right Node로 형성이 되기 때문입니다.
* 위의 경우 연결리스트와 별 다를게 없기 때문에 시간 복잡도는 O(N)이 됩니다.

</div>
</details>